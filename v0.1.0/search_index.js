var documenterSearchIndex = {"docs":
[{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"EditURL = \"../../../examples/compare_warpmaps.jl\"","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"In this demo, we create warp maps from 1) the Higher-order Riesz-wavelet transform, and 2) the Bernstein filtering (BF) method on an unit grid graph.","category":"page"},{"location":"generated/compare_warpmaps_lit/#Setup","page":"Visualize Warp Samples","title":"Setup","text":"","category":"section"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Install dependencies","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"import Pkg\nlet\n    pkgs = [\"LazyGPR\", \"PythonPlot\", \"VisualizationBag\", \"Images\", \"SpatialGSP\"]\n    for pkg in pkgs\n        if Base.find_package(pkg) === nothing\n            Pkg.add(pkg)\n        end\n    end\nend;\n\nimport Random\nRandom.seed!(25)\n\nusing LinearAlgebra\nusing StaticArrays\n\nimport LocalFilters\nimport Images\n\nimport SpatialGSP as GSP\nimport RieszDSP as RZ\nimport LazyGPR as LGP\n\nimport VisualizationBag as VIZ\n\nimport PythonPlot as PLT\nPLT.close(\"all\")\nfig_num = 1\n\nconst T = Float64\nconst D = 2;","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"The following helper scripts can be found in examples/helpers/ from the root repository folder.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"include(\"helpers/utils.jl\")\ninclude(\"helpers/image.jl\")","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"load_kodak_region (generic function with 1 method)","category":"page"},{"location":"generated/compare_warpmaps_lit/#User-inputs","page":"Visualize Warp Samples","title":"User inputs","text":"","category":"section"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"#where the results are saved.\nsave_results_dir = \"output/\"\nif !ispath(save_results_dir)\n    mkpath(save_results_dir)\nend\n\n#pics_folder = joinpath(homedir(), \"work/data/images/kodak/\")\npics_folder = \"data/\"\nimage_path = joinpath(pics_folder, \"kodim23.png\")\n\nimg = loadkodakimage(T, image_path; discard_pixels = 1)\nx_nD, x_ranges = image2samples(img)\nsz_x = size(x_nD);","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"The positions for each pixels. This is a grid, so we represent it as a tuple of range data types.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Xrs = (1:size(x_nD,1), 1:size(x_nD,2))\nim_y = x_nD;","category":"page"},{"location":"generated/compare_warpmaps_lit/#Construct-Warp-Samples","page":"Visualize Warp Samples","title":"Construct Warp Samples","text":"","category":"section"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Warp samples from RieszDSP.jl","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"W_rz = LGP.create_grid_warp_samples(LGP.UseRieszDSP(RZ), im_y)\nσr = 0.5\nσs = 1.0\nW_rz = LocalFilters.bilateralfilter(\n    W_rz, σr, σs, 2*round(Int,3*σs)+1,\n);","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Bernstein filtering, grid graph.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"warp_config = GSP.WarpConfig{T}()\nW_grid = LGP.create_grid_warp_samples(\n    LGP.UseSpatialGSP(GSP),\n    im_y,\n    warp_config,\n);\nW_grid = LocalFilters.bilateralfilter(\n    W_grid, σr, σs, 2*round(Int,3*σs)+1,\n);","category":"page"},{"location":"generated/compare_warpmaps_lit/#Compare-Warp-Samples","page":"Visualize Warp Samples","title":"Compare Warp Samples","text":"","category":"section"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"fig_size = VIZ.getaspectratio(size(im_y)) .* 4\ndpi = 300;","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Input image.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xrs),\n    im_y,\n    [],\n    \"x\",\n    fig_num,\n    \"Image data\";\n    cmap = \"gray\",\n    vmin = 0,\n    vmax = 1,\n    horizontal_title = \"\",\n    vertical_title = \"\",\n    matrix_mode = true,\n    color_bar_shrink = 0.7,\n    fig_size =fig_size = fig_size,\n    dpi = dpi,\n)\nPLT.gcf()","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"(Image: )","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Warp samples using the Higher-order Riesz-wavelet transform.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xrs),\n    W_rz,\n    [],\n    \"x\",\n    fig_num,\n    \"Warp samples via HRWT\";\n    cmap = \"bwr\",\n    symmetric_color_range = true,\n    horizontal_title = \"\",\n    vertical_title = \"\",\n    matrix_mode = true,\n    color_bar_shrink = 0.7,\n    fig_size = fig_size,\n    dpi = dpi,\n)\nPLT.gcf()","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"(Image: )","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"Warp samples from Bernstein filtering. unit grid graph.","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xrs),\n    W_grid,\n    [],\n    \"x\",\n    fig_num,\n    \"Warp samples via BF, grid graph\";\n    cmap = \"bwr\",\n    symmetric_color_range = true,\n    horizontal_title = \"\",\n    vertical_title = \"\",\n    matrix_mode = true,\n    color_bar_shrink = 0.7,\n    fig_size = fig_size,\n    dpi = dpi,\n)\nPLT.gcf()","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"(Image: )","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"","category":"page"},{"location":"generated/compare_warpmaps_lit/","page":"Visualize Warp Samples","title":"Visualize Warp Samples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"api/#Hyperparameter-optimization","page":"Public API","title":"Hyperparameter optimization","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"MarginalLikelihood\nLOOCV\nHCostConfig\nLazyHCostConfig\nMetaheuristicsConfig\nKernelOptimConfig\nUseMetaheuristics\nOptimContainer\ncreate_hp_cost\nfree_hp_cost\noptimize_kernel_hp\noptimize_kernel_hp_separately","category":"page"},{"location":"api/#LazyGPR.MarginalLikelihood","page":"Public API","title":"LazyGPR.MarginalLikelihood","text":"struct MarginalLikelihood\n\nThis is a trait data type that indicates the marginal likelihood should be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.LOOCV","page":"Public API","title":"LazyGPR.LOOCV","text":"struct LOOCV\n\nThis is a trait data type that indicates the leave-one-out cross-validation should be used. See Gaussian Process for Machine Learning (Rasmussen, Williams, 2005, DOI: 10.7551/mitpress/3206.001.0001) for more details.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.HCostConfig","page":"Public API","title":"LazyGPR.HCostConfig","text":"struct HCostConfig\n\nThis is a trait data type that indicates single-process hyperparameter inferenec should be performed. \n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.LazyHCostConfig","page":"Public API","title":"LazyGPR.LazyHCostConfig","text":"struct LazyHCostConfig\n\nThis is a trait and config data type that indicates multi-process hyperparameter inferenec should be performed. It also specifies that the model is the lazy-evaluation GPR, as opposed to a conventional GPR.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.MetaheuristicsConfig","page":"Public API","title":"LazyGPR.MetaheuristicsConfig","text":"@kwdef struct MetaheuristicsConfig <: SolverConfig\n    f_calls_limit::Integer = 1_000\nend\n\nThe optimization configuration for Metaheuristics.jl's \n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.KernelOptimConfig","page":"Public API","title":"LazyGPR.KernelOptimConfig","text":"@kwdef struct KernelOptimConfig{T}\n    a_lb::T\n    a_ub::T\n    κ_ub::T\n    N_initials_a::Int = 100\n    N_initials_κ::Int = 100\n    width_factor::T = one(T)\n    height_factor::T = convert(T, 1/2)\nend\n\nThis configuration is used for the two-stage approach to optimizing DE kernels.\n\nIn the first stage, the stationary kernel is optimized.\n\nIn the second stage, a canonical kernel is formed based on the solution of the stationary kernel's hyperparameters, and the gain parameter is fitted with the canonical kernel bandwidth being fixed.\n\nAbout some of the field members:\n\nN_initials_a and N_initials_κ specifies how many initial guesses are used in the optimization algorithm, sampled at uniformly spaced intervals from the lowerbound to the upperbounds.\nThe gain parameter is κ.\nThe bandwidth parameter is a for the SqExpKernel and WendlandSpline kernels.\nwidth_factor and  height_factor contols how much larger or smaller the DE kernel should be with respect to the bandwidth parameter a from the stationary kernel's optimized solution.\nThe default setting is for the case when the DE kernel should use the stationary kernel's solution as its canonical kernel.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.UseMetaheuristics","page":"Public API","title":"LazyGPR.UseMetaheuristics","text":"struct UseMetaheuristics\n\nThis is a trait data type that indicates Metaheuristics.jl should be used for optimization. Usage:\n\nimport Metaheuristics as EVO\nopt_trait = UseMetaheuristics(EVO)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.OptimContainer","page":"Public API","title":"LazyGPR.OptimContainer","text":"struct OptimContainer{T}\n    lbs::Vector{T}\n    ubs::Vector{T}\n    p0s::Vector{Vector{T}}\nend\n\nA container for optimization problems. lbs and ubs are the lower and upper bounds, respectively. p0s is an array of initial guesses.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.create_hp_cost","page":"Public API","title":"LazyGPR.create_hp_cost","text":"create_hp_cost(::UseDistributedComputing, args...)\n\nCreates the hyperparameter cost function for a distributed computing setup.\n\n\n\n\n\ncreate_hp_cost(::Nothing, args...)\n\nCreates the hyperparameter cost function for a single-process setup.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.free_hp_cost","page":"Public API","title":"LazyGPR.free_hp_cost","text":"free_hp_cost(Bs_info::DData.Dinfo)\n\nFrees up the data specified in Bs_info, which was used by create_hp_cost and run_optimizer.\n\n\n\n\n\nfree_hp_cost(::Nothing, args...)\n\nThere is no workers to free for a single-process setup. This function does nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.optimize_kernel_hp","page":"Public API","title":"LazyGPR.optimize_kernel_hp","text":"optimize_kernel_hp(\n    alg_trait::ExtensionPkgs,\n    kernel::PositiveDefiniteKernel,\n    ms_trait::ModelSelection,\n    model::Union{LazyGP,GPData},\n    config::HyperparameterInferenceInfo,\n    solver_config::SolverConfig,\n    optim_info::OptimContainer{T},\n) where T <: Real\n\nFits the GPR hyperparameters for a single-process setup.\n\n\n\n\n\noptimize_kernel_hp(\n    alg_trait::ExtensionPkgs,\n    ref_sk::StationaryKernel,\n    ms_trait::ModelSelection,\n    model::Union{LazyGP,GPData},\n    config::HyperparameterInferenceInfo,\n    solver_config::SolverConfig,\n    optim_config::KernelOptimConfig,\n)\n\nFits the GPR hyperparameters for multi-process, distributed computing setup.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.optimize_kernel_hp_separately","page":"Public API","title":"LazyGPR.optimize_kernel_hp_separately","text":"optimize_kernel_hp_separately(\n    alg_trait::ExtensionPkgs,\n    ref_dek::DEKernel,\n    ms_trait::ModelSelection,\n    model::Union{LazyGP,GPData},\n    config::HyperparameterInferenceInfo,\n    solver_config::SolverConfig,\n    optim_config::KernelOptimConfig{T},\n) where T <: Real\n\nThe two-stage approach to optimizing the DE kernel hyperparameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#Warp-sample-construction","page":"Public API","title":"Warp sample construction","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"create_grid_warp_samples\ncreate_warp_samples\nAxisGraph\nKNNGraph\nUseRieszDSP\nUseSpatialGSP\nUseInterpolations\nUseScatteredInterpolation","category":"page"},{"location":"api/#LazyGPR.create_grid_warp_samples","page":"Public API","title":"LazyGPR.create_grid_warp_samples","text":"create_grid_warp_samples(\n    alg_trait::UseSpatialGSP,\n    y_nD::AbstractArray{T},\n    warp_config;\n    smooth_iters::Integer = 0,\n) where T\n\nReturns an array of warp samples, constructed using the Bernstein filtering method with a unit grid graph.\n\nIn the current implementation, warp_config should be a data type of SpatialGSP.WarpConfig.\n\nAs a post-processing step, smooth_iters performs smoothing by applying the adjacency matrix to the warp samples smooth_iters times.\n\n\n\n\n\ncreate_grid_warp_samples(\n    alg_trait::UseRieszDSP,\n    y_nD::AbstractArray{T};\n    N_scales = 0\n) where T\n\nReturns an array of warp samples, constructed using the higher-order Riesz-wavelet transform, implemented in the RieszDSP.jl package.\n\nN_scales is the number of wavelet bands to use. The default value of 0 means the following is used:\n\nN_scales = round(Int, log2( maximum(size(y_nD))))\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.create_warp_samples","page":"Public API","title":"LazyGPR.create_warp_samples","text":"function create_warp_samples(\n    alg_trait::UseSpatialGSP,\n    graph_trait::GraphTrait,\n    X::Vector{AV},\n    y::Vector{T},\n    graph_config,\n    warp_config;\n    smooth_iters::Integer = 0,\n) where {T <: Real, AV <: AbstractVector{T}}\n\nReturns an array of warp samples, constructed using the Bernstein filtering method with a graph construction method specified by graph_trait.\n\nIn the current implementation, warp_config should be a data type of SpatialGSP.WarpConfig, and graph_trait can be of the dispatch types AxisGraph and KNNGraph.\n\nAs a post-processing step, smooth_iters performs smoothing by applying the adjacency matrix to the warp samples smooth_iters times.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.AxisGraph","page":"Public API","title":"LazyGPR.AxisGraph","text":"struct AxisGraph\n\nThis is a trait data type that indicates the axis-search graph construction method should be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.KNNGraph","page":"Public API","title":"LazyGPR.KNNGraph","text":"struct KNNGraph\n    This is a trait data type that indicates the k-nearest neighbors graph construction method, with forced symmetry to generate undirected graphs, should be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.UseRieszDSP","page":"Public API","title":"LazyGPR.UseRieszDSP","text":"struct UseRieszDSP\n\nThis is a trait data type that indicates RieszDSP.jl should be used for constructing the warp samples. Usage:\n\nimport RieszDSP as RZ\nwarp_graph_trait = UseRieszDSP(RZ)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.UseSpatialGSP","page":"Public API","title":"LazyGPR.UseSpatialGSP","text":"struct UseSpatialGSP\n\nThis is a trait data type that indicates SpatialGSP.jl should be used for constructing the warp samples. Usage:\n\nimport SpatialGSP as GSP\nwarp_graph_trait = UseSpatialGSP(GSP)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.UseInterpolations","page":"Public API","title":"LazyGPR.UseInterpolations","text":"struct UseInterpolations\n\nThis is a trait data type that indicates Interpolations.jl should be used to construct a warp function from a set of warp samples. Usage:\n\nimport Interpolations\nitp_trait = UseInterpolations(Interpolations)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.UseScatteredInterpolation","page":"Public API","title":"LazyGPR.UseScatteredInterpolation","text":"struct UseScatteredInterpolation\n\nThis is a trait data type that indicates ScatteredInterpolation.jl should be used to construct a warp function from a set of warp samples. Usage:\n\nimport ScatteredInterpolation\nitp_trait = UseScatteredInterpolation(ScatteredInterpolation)\n\n\n\n\n\n","category":"type"},{"location":"api/#Kernels","page":"Public API","title":"Kernels","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"WendlandSplineKernel\nOrder1\nOrder2\nOrder3\nSqExpKernel\nDEKernel\nevalkernel\nevalde\nevalwarpmap","category":"page"},{"location":"api/#LazyGPR.WendlandSplineKernel","page":"Public API","title":"LazyGPR.WendlandSplineKernel","text":"struct WendlandSplineKernel{T <: AbstractFloat, N} <: DistanceKernel\n    a::T\n\n    # buffer.\n    l::Int\n    c::NTuple{N,T}\n    m::Int\nend\n\nThe Wendland spline kernels, which are compactly supported. See (Wendland 2004, DOI: 10.1017/CBO9780511617539) for more information.\n\na controls the bandwidth. Must be larger than zero.\nl, c, m are internal intermediate objects that represent a Wendland spline of a specified order and dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.Order1","page":"Public API","title":"LazyGPR.Order1","text":"struct Order1\n\nThis is a trait data type that indicates the order is 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.Order2","page":"Public API","title":"LazyGPR.Order2","text":"struct Order2\n\nThis is a trait data type that indicates the order is 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.Order3","page":"Public API","title":"LazyGPR.Order3","text":"struct Order3\n\nThis is a trait data type that indicates the order is 3.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.SqExpKernel","page":"Public API","title":"LazyGPR.SqExpKernel","text":"struct SqExpKernel{T <: AbstractFloat} <: SqDistanceKernel     a::T end\n\nThe square exponential kernel. a must be larger than zero. If τ is the distance input, then the kernel output is:\n\nexp(-a*τ)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.DEKernel","page":"Public API","title":"LazyGPR.DEKernel","text":"struct DEKernel{T <: AbstractFloat, WT, KT <: StationaryKernel} <: DEKernelFamily\n    canonical::KT\n    warpmap::WT # this is a callable function.\n    κ::T\nend\n\nThe dimensional expansion (DE) kernel container data type.\n\ncanonical is the canonical kernel. It should be a stationary kernel.\nwarpmap is the warp function before the application of the gain multiplier.\nκ is the gain. Must be non-negative.\n\nIf x, z are inputs, then the kernel evaluates to:\n\nevalkernel(\n    canonical,\n    norm( [x; κ*warpmap(x)] - [z; κ*warpmap(z)] ),\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.evalkernel","page":"Public API","title":"LazyGPR.evalkernel","text":"evalkernel(τ::Real, θ::WendlandSplineKernel{T,N})::T where {T <: AbstractFloat, N}\n\nEvaluates the Wendland spline kernel θ.\n\n\n\n\n\nevalkernel(τ::Real, θ::ExpKernel{T})::T where T <: AbstractFloat\n\nEvaluates the exponential (Ornstein–Uhlenbeck) kernel θ.\n\n\n\n\n\nevalkernel(τ::Real, θ::Matern3Halfs{T})::T where T <: AbstractFloat\n\nEvaluates the Matern 3/2 kernel θ.\n\n\n\n\n\nevalkernel(τ_sq::Real, θ::RQKernel{T,ET})::T where {T <: AbstractFloat, ET}\n\nEvaluates the rational quadratic kernel θ.\n\n\n\n\n\nevalkernel(τ_sq::Real, θ::SqExpKernel{T})::T where T <: AbstractFloat\n\nEvaluates the square exponential kernel θ.\n\n\n\n\n\nevalkernel(x::Real, dek::DEKernelFamily)\n\nEvaluates the canonical kernel in dek with the scalar input x. Note that DE kernels can only be evaluated for vector inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.evalde","page":"Public API","title":"LazyGPR.evalde","text":"evalde(dek::DEKernel{T}, x)::T where T <: AbstractFloat\n\nApplies the gain κ.\n\nEvaluates:\n\ndek.κ*dek.warpmap(x)\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.evalwarpmap","page":"Public API","title":"LazyGPR.evalwarpmap","text":"evalde(dek::DEKernel{T}, x)::T where T <: AbstractFloat\n\nDoes not apply the gain κ.\n\nEvaluates:\n\ndek.warpmap(x)\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-specification","page":"Public API","title":"Model specification","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"AdjustmentMap\nGPData\ncreate_local_procs\nevalsmap\nLazyGP\nfitGP\nfitGP!","category":"page"},{"location":"api/#LazyGPR.AdjustmentMap","page":"Public API","title":"LazyGPR.AdjustmentMap","text":"struct AdjustmentMap{T <: AbstractFloat}\n    a::T\n    b::T\n    L::Int\nend\n\nContainer type for the observation variance adjustment map.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.GPData","page":"Public API","title":"LazyGPR.GPData","text":"struct GPData{T, D, XT <: Union{Vector, SpatialSearchContainer, NTuple}}\n    σ²::T\n    inputs::XT\n    outputs::Array{T,D}\nend\n\nContainer type for a conventional GPR model.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.create_local_procs","page":"Public API","title":"LazyGPR.create_local_procs","text":"create_local_procs(\n    n_new_workers::Integer;\n    pkg_load_list::Vector{Expr} = Vector{Expr}(undef, 0),\n    verbose = true,\n)\n\nCreates n_new_workers many new workers, and loads the packages in pkg_load_list on each worker.\n\nPlease manually check whether your current Julia session can actually benefit from launching n_new_workers new workers. For example, the number of workers should not exceed the number of physical floating-point cores in your distributed computing environment.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.evalsmap","page":"Public API","title":"LazyGPR.evalsmap","text":"evalsmap(x, s::AdjustmentMap{T}) where T\n\nEvaluates the ξ curve from the adjustment map container s, at distance x.\n\n\n\n\n\nfunction evalsmap(u, x, s::AdjustmentMap)\n\nEvaluates:\n\nevalsmap(norm(u-x), s)\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.LazyGP","page":"Public API","title":"LazyGPR.LazyGP","text":"struct LazyGP{T, ST <: Union{Nothing, AdjustmentMap{T}}, XT, D}\n    b_x::T\n    s_map::ST\n    data::GPData{T, D, XT}\nend\n\nContainer type for a the lazy-evaluation GPR model.\n\nb_x is the local neighborhood radius.\ns_map is the adjustment map for the observation noise model.\ndata contains the GPR data.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.fitGP","page":"Public API","title":"LazyGPR.fitGP","text":"fitGP(X::Vector, y::Vector{T}, σ²::AbstractFloat, θ) where T <: AbstractFloat\n\nFit a conventional GPR model.\n\nU: kernel matrix buffer. Mutates.\nbuffer: pair-wise distance buffer. Mutates.\ny: training outputs.\nσ²: observation noise variance.\nθ: the covariance function.\n\nReturns an object of type DenseGPModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.fitGP!","page":"Public API","title":"LazyGPR.fitGP!","text":"fitGP!(\n    U::Matrix{T}, # mutates.\n    buffer::RcBuffer, # mutates.\n    y::Vector{T},\n    σ²::T,\n    θ::PositiveDefiniteKernel,\n) where T\n\nFit a conventional GPR model.\n\nU: kernel matrix buffer. Mutates.\nbuffer: pair-wise distance buffer. Mutates.\ny: training outputs.\nσ²: observation noise variance.\nθ: the covariance function.\n\nReturns:\n\nc: the cached coefficients for querying any predictive mean.\nC: the Cholesky factor for U = K + σ²I, where K is the kernel matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-query","page":"Public API","title":"Model query","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"QueryOptions\ncomputecachevars\nsetup_query_dc\nquery_dc\nfree_query_dc\nqueryGP","category":"page"},{"location":"api/#LazyGPR.QueryOptions","page":"Public API","title":"LazyGPR.QueryOptions","text":"@kwdef struct QueryOptions{MT <: BinarySelection, VT <: BinarySelection}\n    compute_mean::MT = Enable()\n    compute_variance::VT = Enable()\nend\n\nSpecifies whether the predicitve mean and/or the predictive variance should be computed during querying.\n\nPossible values for each are: LazyGPR.Enabled() and LazyGPR.Disabled().\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyGPR.computecachevars","page":"Public API","title":"LazyGPR.computecachevars","text":"computecachevars(::StationaryKernel, args...)\n\n\n\n\n\ncomputecachevars(dek::DEKernel, model::LazyGP)\n\nComputes and stores the warpmap evaluations at each training input in model.\n\n\n\n\n\ncomputecachevars(dek::DEKernel, data::GPData)\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.setup_query_dc","page":"Public API","title":"LazyGPR.setup_query_dc","text":"setup_query_dc(\n    worker_list,\n    model::LazyGP,\n    θ::PositiveDefiniteKernel,\n    options::QueryOptions,\n    cvars::CacheInfo,\n)\n\nLoads the neccessary data to the workers in worker_list in preparation to run batch query for the lazy-evaluation GPR model, model, under a distributed computing setup.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.query_dc","page":"Public API","title":"LazyGPR.query_dc","text":"query_dc(Xq::Vector, worker_list::Vector{Int})\n\nQuery the lazy-evaluation GPR model that was setup by a previous call to setup_query_dc.\n\nThe user should call free_query_dc after this function.\n\n\n\n\n\nquery_dc(Xqrs::NTuple{D, AR}, worker_list::Vector{Int}) where {D, AR <: AbstractRange}\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.free_query_dc","page":"Public API","title":"LazyGPR.free_query_dc","text":"free_query_dc(worker_list)\n\nFree the data used by the setup_query_dc and query_dc() functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyGPR.queryGP","page":"Public API","title":"LazyGPR.queryGP","text":"queryGP(xrs::NTuple{D, AR}, θ, model::DenseGPModel) where {D, AR <: AbstractRange}\n\nQuery a conventional GPR at input xrs.\n\n\n\n\n\nqueryGP(\n    xq::AbstractVector{T},\n    dek::DEKernel,\n    model::DenseGPModel{T},\n) where T <: AbstractFloat\n\n\n\n\n\n","category":"function"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"EditURL = \"../../../examples/rainfall.jl\"","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"In this demo, we compare the query from a DE kernel GPR and a stationary kernel GPR. Please make sure the RWPublicJuliaRegistry custom registry is installed. You can install it by running the command using Pkgpkg\"registry add General https://github.com/RoyCCWang/RWPublicJuliaRegistry\"`","category":"page"},{"location":"generated/rainfall_lit/#Setup","page":"Demo: Oscillation Reduction","title":"Setup","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"#Install dependencies\nimport Pkg\nlet\n    pkgs = [\"SingleLinkagePartitions\", \"Distances\", \"DataFrames\", \"CSV\", \"Metaheuristics\", \"LazyGPR\", \"PythonPlot\", \"VisualizationBag\", \"Statistics\", \"SpatialGSP\"]\n    for pkg in pkgs\n        if Base.find_package(pkg) === nothing\n            Pkg.add(pkg)\n        end\n    end\nend;\n\n#load\nimport Random\nRandom.seed!(25)\n\nusing LinearAlgebra\nusing Statistics\n\nimport Distances\nimport LazyGPR as LGP\nimport SingleLinkagePartitions as SL\nimport SpatialGSP as GSP\n\nimport Metaheuristics as EVO\nimport DataFrames as DF\nimport CSV\n\nimport VisualizationBag as VIZ\nimport PythonPlot as PLT\nPLT.close(\"all\")\nfig_num = 1\n\nT = Float64\nD = 2;","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"User inputs","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"save_results_dir = \"output/\"\nif !ispath(save_results_dir)\n    mkpath(save_results_dir)\nend\n\n#optimization-related.\nf_calls_limit = 1_000\nms_trait = LGP.MarginalLikelihood()\n\n#observation model's variance.\nσ² = convert(T, 1e-3);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Get the training inputs, X, and outputs, y.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"data_path = \"data/2023_08_10_CA_stations.csv\"\ndf = CSV.read(data_path, DF.DataFrame)\n\nX0 = collect(\n    [\n        df.LATITUDE[n];\n        df.LONGITUDE[n];\n    ]\n    for n in eachindex(df.LATITUDE)\n)\ny0 = convert(Vector{T}, df.PRCP ./ 10)\nX, y = SL.avgduplicates(X0, y0, eps(T)*10);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Compute warp samples that uses an axis-search graph construction, for scattered positions.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"axis_config = GSP.AxisSearchConfig{T}(\n    kernel_σ_multiplier = convert(T, 3),\n    w_lb = convert(T, 0.1),\n)\nwarp_config = GSP.WarpConfig{T}()\nsmooth_iters = 0\nW = LGP.create_warp_samples(\n    LGP.UseSpatialGSP(GSP),\n    LGP.AxisGraph(),\n    X, y,\n    axis_config,\n    warp_config,\n);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Create warp map from the samples.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"import ScatteredInterpolation\nwarpmap = LGP.create_warp_map(\n    LGP.UseScatteredInterpolation(ScatteredInterpolation),\n    X, W, 3,\n);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Create the reference (dummy) DE Kernel that uses this warpmap.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"ref_dek = LGP.DEKernel(\n    LGP.SqExpKernel(one(T)), warpmap, zero(T),\n);","category":"page"},{"location":"generated/rainfall_lit/#Hyperparameter-Optimization","page":"Demo: Oscillation Reduction","title":"Hyperparameter Optimization","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Settings and variable bounds.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"a_lb = convert(T, 1e-3)\na_ub = convert(T, 60)\nN_initials_a = 100 #the number of intial guesses for optimizing the bandwidth a.\n\nκ_lb = zero(T)\nκ_ub = maximum(abs.(W))*100 #increase this until the solution gain does is not clipped by this value.\nN_initials_κ = 1_000; #the number of intial guesses for optimizing the gain κ.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Put data in container.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"gp_data = LGP.GPData(σ², X, y);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"We reset the random seed since the evolutionary optimization algorithm from Metaheuristics.jl is a random one.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Random.seed!(25)\n\nsk_ref = ref_dek.canonical\np0s = collect( [x;] for x in LinRange(a_lb, a_ub, 100) )\nsk_vars, sk_star = LGP.optimize_kernel_hp(\n    LGP.UseMetaheuristics(EVO),\n    sk_ref,\n    ms_trait,\n    gp_data,\n    LGP.HCostConfig(),\n    LGP.MetaheuristicsConfig(\n        f_calls_limit = f_calls_limit,\n    ),\n    LGP.OptimContainer([a_lb;], [a_ub;], p0s)\n);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"The solution, score (lower is better):","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"sk_vars, sk_star","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"([30.192289102857256], 61618.821175642646)","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Reset the seed for the DE Kernel.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Random.seed!(25)\n\na0s = collect(LinRange(a_lb, a_ub, 10))\npush!(a0s, sk_vars[begin])\nκ0s = LinRange(0, κ_ub, 20)\np0s = collect.(\n    vec(collect(Iterators.product(a0s, κ0s)))\n)\ndek_vars, dek_star = LGP.optimize_kernel_hp(\n    LGP.UseMetaheuristics(EVO),\n    ref_dek,\n    ms_trait,\n    gp_data,\n    LGP.HCostConfig(),\n    LGP.MetaheuristicsConfig(\n        f_calls_limit = f_calls_limit,\n    ),\n    LGP.OptimContainer([a_lb; zero(T)], [a_ub; κ_ub;], p0s)\n);","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"The solution (bandwidth, gain), score (lower is better):","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"dek_vars, dek_star","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"([0.23724657135499885, 23.1197898840871], 22804.40630587782)","category":"page"},{"location":"generated/rainfall_lit/#Query","page":"Demo: Oscillation Reduction","title":"Query","text":"","category":"section"},{"location":"generated/rainfall_lit/#Setup-query-region","page":"Demo: Oscillation Reduction","title":"Setup query region","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Near Ottawa, Ontario, Canada.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"x1_lb, x1_ub = 42.0, 51.0 # latitude bounds\nx2_lb, x2_ub = -80.0, -68.0 # longitude bounds\n\n#number of query points.\nNq1 = 90\nNq2 = 120\nXqrs = ( # query grid, represented as ranges.\n    LinRange(x1_lb, x1_ub, Nq1),\n    LinRange(x2_lb, x2_ub, Nq2),\n)\nXq = collect( Iterators.product(Xqrs...) ); #query positions.","category":"page"},{"location":"generated/rainfall_lit/#Stationary-Kernel-Model","page":"Demo: Oscillation Reduction","title":"Stationary Kernel Model","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"sk = LGP.SqExpKernel(sk_vars[begin]) #assemble the kernel\ngp_sk = LGP.fitGP(X, y, σ², sk) #fit GPR model\n\nsk_Xq = collect(\n    LGP.queryGP(collect(x), sk, gp_sk)\n    for x in Iterators.product(Xqrs...)\n)\nmqs_sk = map(xx->xx[begin], sk_Xq) #predictive mean\nvqs_sk = map(xx->xx[begin+1], sk_Xq); #predictive variance","category":"page"},{"location":"generated/rainfall_lit/#DE-kernel's-canonical-kernel-model","page":"Demo: Oscillation Reduction","title":"DE kernel's canonical kernel model","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"ck = LGP.SqExpKernel(dek_vars[begin]) #assemble kernel\ngp_ck = LGP.fitGP(X, y, σ², ck) #fit GPR\n\nck_Xq = collect(\n    LGP.queryGP(collect(x), ck, gp_ck)\n    for x in Iterators.product(Xqrs...)\n)\nmqs_ck = map(xx->xx[begin], ck_Xq) #predictive mean\nvqs_ck = map(xx->xx[begin+1], ck_Xq); #predictive variance","category":"page"},{"location":"generated/rainfall_lit/#DE-kernel-model","page":"Demo: Oscillation Reduction","title":"DE kernel model","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"a_star, κ_star = dek_vars\ndek = LGP.DEKernel( #Assemble DE kernel.\n    LGP.SqExpKernel(a_star),\n    warpmap,\n    κ_star,\n)\ngp_dek = LGP.fitGP(X, y, σ², dek); #Fit DE kernel GPR.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Query the model.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"dek_Xq = collect(\n    LGP.queryGP(collect(x), dek, gp_dek)\n    for x in Iterators.product(Xqrs...)\n)\n\nmqs_dek = map(xx->xx[begin], dek_Xq) #predictive mean\nvqs_dek = map(xx->xx[begin+1], dek_Xq); #predictive variance","category":"page"},{"location":"generated/rainfall_lit/#Visualize","page":"Demo: Oscillation Reduction","title":"Visualize","text":"","category":"section"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"dpi = 300\ncmap = \"bwr\" # colormap for predictive means\nvar_cmap = \"Greys\"; # for variance","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"For consistent visual comparison of the means, clamp colors to the max magnitude range of the data, and force symmetry about zero.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"vmax = maximum(y)\nvmin = -vmax;","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"DE kernel model, mean:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    mqs_dek,\n    X,\n    \"o\",\n    fig_num,\n    \"DE kernel - predictive mean\";\n    cmap = cmap,\n    vmin = vmin,\n    vmax = vmax,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"DE kernel model, variance:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    vqs_dek,\n    X,\n    \"o\",\n    fig_num,\n    \"DE kernel - predictive variance\";\n    cmap = var_cmap,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Stationary kernel model, mean:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    mqs_sk,\n    X,\n    \"o\",\n    fig_num,\n    \"Stationary kernel - predictive mean\";\n    cmap = cmap,\n    vmin = vmin,\n    vmax = vmax,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Stationary kernel model, variance:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    vqs_sk,\n    X,\n    \"o\",\n    fig_num,\n    \"Stationary kernel - predictive variance\";\n    cmap = var_cmap,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Canonical kernel model, mean:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    mqs_ck,\n    X,\n    \"o\",\n    fig_num,\n    \"Canonical kernel - predictive mean\";\n    cmap = cmap,\n    vmin = vmin,\n    vmax = vmax,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"Canonical kernel model, variance:","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"fig_num = VIZ.plotmeshgrid2D(\n    PLT,\n    collect(Xqrs),\n    vqs_ck,\n    X,\n    \"o\",\n    fig_num,\n    \"Canonical kernel - predictive variance\";\n    cmap = var_cmap,\n    horizontal_title = \"Longitude\",\n    vertical_title = \"Latitude\",\n    matrix_mode = true,\n)\nPLT.gca().invert_yaxis()\nPLT.gcf()","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"(Image: )","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"The caonical kernel model exhibits significant Runge's phenomenon-like oscillatory behavior. The stationary kernel model has little oscillatory behavior, but has significantly reduced smoothing radius/ability. The DE kernel actually uses the same smoothing radius/ability as the canonical kernel, but it adjusts the smoothing amount across space to reduce oscillations.","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"","category":"page"},{"location":"generated/rainfall_lit/","page":"Demo: Oscillation Reduction","title":"Demo: Oscillation Reduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"EditURL = \"../../../examples/s_map.jl\"","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"In this demo, we visualize the variance adjustment map curve, ξ, looks like. You can use this type of visualization to choose the tuning parameters L, x0, and y0 for the adjustment map.","category":"page"},{"location":"generated/s_map_lit/#Setup","page":"Visualize Adjustment Map","title":"Setup","text":"","category":"section"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"Install dependencies","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"import Pkg\nlet\n    pkgs = [\"LazyGPR\", \"PythonPlot\", \"VisualizationBag\", \"Images\", \"SpatialGSP\"]\n    for pkg in pkgs\n        if Base.find_package(pkg) === nothing\n            Pkg.add(pkg)\n        end\n    end\nend;\n\nusing LinearAlgebra\nimport Random\nRandom.seed!(25)\n\nimport LazyGPR as LGP\n\nimport PythonPlot as PLT\nPLT.close(\"all\")\nfig_num = 1\n\nconst T = Float64;","category":"page"},{"location":"generated/s_map_lit/#User-Inputs","page":"Visualize Adjustment Map","title":"User Inputs","text":"","category":"section"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"b_x = convert(T, 5) # the neighborhood radius.\nM = floor(Int, b_x)","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"5","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"The exponent L must be an even positive integer. The larger the flatter.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"L = M # We made an arbitrary choice here, as this is a tuning parameter. Feel free to try another positive even integer.\nif isodd(L)\n    L = L + 1\nend","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"6","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"We specify a point that the curve must pass through. This point is a tuning parameter; feel free to try another point.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"x0, y0 = convert(T, 0.8*M), 1 + convert(T, 0.5)","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"(4.0, 1.5)","category":"page"},{"location":"generated/s_map_lit/#Visualize-Adjustment-Map","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"","category":"section"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"Construct the adjustment map container.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"s = LGP.AdjustmentMap(x0, y0, b_x, L)\n@assert s.a > 0 # try a different (x0, y0) if s.a is negative or too small.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"Specify the plotting area.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"viz_bound = 0.9 # this is a number between 0 and 1 that controls the plot's domain. closer to 1 means the plot will tend closer to infinity near the upper boundary of the plot.\nu_range = LinRange(0, viz_bound*M, 1000)","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"1000-element LinRange{Float64, Int64}:\n 0.0, 0.0045045, 0.00900901, 0.0135135, …, 4.48649, 4.49099, 4.4955, 4.5","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"Setup the ξ curve.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"ξ = uu->LGP.evalsmap(uu, s)\n@assert abs(ξ(x0)-y0) < eps(T)*100 # see if g passes through the point (x0,y0).","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"Plot.","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"PLT.figure(fig_num)\nfig_num += 1\n\nPLT.plot(u_range, ξ.(u_range), label = \"g\")\n\nPLT.legend()\nPLT.title(\"RQ\")\nPLT.gcf()","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"(Image: )","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"","category":"page"},{"location":"generated/s_map_lit/","page":"Visualize Adjustment Map","title":"Visualize Adjustment Map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LazyGPR.jl","page":"Overview","title":"LazyGPR.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package implements the hyperparameter optimization and querying routines for the lazy-evaluation GPR model.","category":"page"}]
}
